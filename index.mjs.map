{"version":3,"file":"index.mjs","sources":["../lib/is_array_like_object.js","../lib/copy_view.js","../lib/main.js","../lib/defaults.js","../lib/expand_shape.js","../lib/expand_strides.js","../lib/cast_buffer.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport PINF from '@stdlib/constants-float64-pinf';\nimport isInteger from '@stdlib/math-base-assert-is-integer';\n\n\n// MAIN //\n\n/**\n* Tests (loosely) if an input value is an array-like object.\n*\n* @private\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating if an input value is an array-like object\n*\n* @example\n* var bool = isArrayLikeObject( [] );\n* // returns true\n*\n* @example\n* var bool = isArrayLikeObject( '' );\n* // returns false\n*/\nfunction isArrayLikeObject( value ) {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\ttypeof value.length === 'number' &&\n\t\tisInteger( value.length ) &&\n\t\tvalue.length >= 0 &&\n\t\tvalue.length < PINF\n\t);\n}\n\n\n// EXPORTS //\n\nexport default isArrayLikeObject;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport arraylike2object from '@stdlib/array-base-arraylike2object';\nimport castReturn from '@stdlib/complex-base-cast-return';\nimport complexCtors from '@stdlib/complex-ctors';\nimport bufferCtors from '@stdlib/ndarray-base-buffer-ctors';\nimport allocUnsafe from '@stdlib/buffer-alloc-unsafe';\nimport ndarray from '@stdlib/ndarray-base-ctor';\nimport getDType from '@stdlib/ndarray-dtype';\nimport getShape from '@stdlib/ndarray-shape';\nimport getStrides from '@stdlib/ndarray-strides';\nimport getOffset from '@stdlib/ndarray-offset';\nimport getOrder from '@stdlib/ndarray-order';\nimport getData from '@stdlib/ndarray-data-buffer';\n\n\n// FUNCTIONS //\n\n/**\n* Copies a \"generic\" ndarray view.\n*\n* @private\n* @param {ndarray} arr - input ndarray\n* @returns {Array} output data buffer\n*/\nfunction generic( arr ) {\n\tvar len;\n\tvar out;\n\tvar i;\n\n\tlen = arr.length;\n\tout = [];\n\tfor ( i = 0; i < len; i++ ) {\n\t\tout.push( arr.iget( i ) ); // as output buffer is generic, should work with both real- and complex-valued ndarrays\n\t}\n\treturn out;\n}\n\n/**\n* Copies a \"binary\" ndarray view.\n*\n* @private\n* @param {ndarray} arr - input ndarray\n* @returns {Array} output data buffer\n*/\nfunction binary( arr ) {\n\tvar len;\n\tvar out;\n\tvar i;\n\n\tlen = arr.length;\n\tout = allocUnsafe( len );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tout[ i ] = arr.iget( i ); // we're assuming that we're doing something sensible here (e.g., not trying to cast a complex-valued ndarray to a \"binary\" ndarray or a double-precision floating-point ndarray to binary, etc)\n\t}\n\treturn out;\n}\n\n/**\n* Copies a \"typed\" ndarray view.\n*\n* @private\n* @param {ndarray} arr - input ndarray\n* @param {string} dtype - data type\n* @returns {Array} output data buffer\n*/\nfunction typed( arr, dtype ) {\n\tvar ctor;\n\tvar len;\n\tvar out;\n\tvar set;\n\tvar fcn;\n\tvar o;\n\tvar i;\n\n\tctor = bufferCtors( dtype );\n\tlen = arr.length;\n\tout = new ctor( len );\n\n\t// If the output data buffer is a complex number array, we need to use accessors...\n\to = arraylike2object( out );\n\tif ( o.accessorProtocol ) {\n\t\tset = o.accessors[ 1 ];\n\t\tfcn = castReturn( wrapper, 1, complexCtors( dtype ) );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tset( out, i, fcn( i ) ); // we're assuming that we're doing something sensible here (e.g., not trying to cast arbitrary objects to complex numbers, etc)\n\t\t}\n\t} else {\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr.iget( i ); // we're assuming that we're doing something sensible here (e.g., not trying to cast an ndarray containing generic objects to a double-precision floating-point array or a complex-valued ndarray to a real-valued ndarray, etc)\n\t\t}\n\t}\n\treturn out;\n\n\t/**\n\t* Returns the ndarray element specified by a provided linear index.\n\t*\n\t* @private\n\t* @param {NonNegativeInteger} i - linear index\n\t* @returns {*} value\n\t*/\n\tfunction wrapper( i ) {\n\t\treturn arr.iget( i );\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Copies an ndarray view to a data buffer.\n*\n* @private\n* @param {ndarray} arr - input ndarray\n* @param {string} dtype - data type\n* @returns {(Array|TypedArray|Buffer)} output data buffer\n*\n* @example\n* import ndarray from '@stdlib/ndarray-ctor';\n*\n* var buffer = [ 1.0, 2.0, 3.0 ];\n* var shape = [ 3 ];\n* var strides = [ -1 ];\n* var vec = ndarray( 'generic', buffer, shape, strides, 2, 'row-major' );\n*\n* var b = copyView( vec, 'float64' );\n* // returns <Float64Array>[ 3.0, 2.0, 1.0 ]\n*/\nfunction copyView( arr, dtype ) {\n\tvar x;\n\n\t// Create a new \"base\" view, thus ensuring we have an `.iget` method and associated meta data...\n\tx = new ndarray( getDType( arr ), getData( arr ), getShape( arr ), getStrides( arr ), getOffset( arr ), getOrder( arr ) ); // eslint-disable-line max-len\n\n\tif ( dtype === 'generic' ) {\n\t\treturn generic( x );\n\t}\n\tif ( dtype === 'binary' ) {\n\t\treturn binary( x );\n\t}\n\treturn typed( x, dtype );\n}\n\n\n// EXPORTS //\n\nexport default copyView;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport isObject from '@stdlib/assert-is-plain-object';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport isArray from '@stdlib/assert-is-array';\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport shape2strides from '@stdlib/ndarray-base-shape2strides';\nimport strides2offset from '@stdlib/ndarray-base-strides2offset';\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport numel from '@stdlib/ndarray-base-numel';\nimport ndarray from '@stdlib/ndarray-ctor';\nimport isDataType from '@stdlib/ndarray-base-assert-is-data-type';\nimport isOrder from '@stdlib/ndarray-base-assert-is-order';\nimport isCastingMode from '@stdlib/ndarray-base-assert-is-casting-mode';\nimport isAllowedCast from '@stdlib/ndarray-base-assert-is-allowed-data-type-cast';\nimport createBuffer from '@stdlib/ndarray-base-buffer';\nimport getBufferDType from '@stdlib/ndarray-base-buffer-dtype';\nimport getDType from '@stdlib/ndarray-dtype';\nimport getShape from '@stdlib/ndarray-shape';\nimport getStrides from '@stdlib/ndarray-strides';\nimport getOffset from '@stdlib/ndarray-offset';\nimport getOrder from '@stdlib/ndarray-order';\nimport getData from '@stdlib/ndarray-data-buffer';\nimport arrayShape from '@stdlib/array-shape';\nimport flatten from '@stdlib/array-base-flatten';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport isArrayLikeObject from './is_array_like_object.js';\nimport getDefaults from './defaults.js';\nimport castBuffer from './cast_buffer.js';\nimport copyView from './copy_view.js';\nimport expandShape from './expand_shape.js';\nimport expandStrides from './expand_strides.js';\n\n\n// VARIABLES //\n\nvar defaults = getDefaults();\n\n\n// MAIN //\n\n/**\n* Returns a multidimensional array.\n*\n* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [buffer] - data source\n* @param {Options} [options] - function options\n* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [options.buffer] - data source\n* @param {string} [options.dtype=\"float64\"] - underlying storage data type (if the input data is not of the same type, this option specifies the data type to which to cast the input data)\n* @param {string} [options.order=\"row-major\"] - specifies the memory layout of the array as either row-major (C-style) or column-major (Fortran-style)\n* @param {NonNegativeIntegerArray} [options.shape] - array shape\n* @param {string} [options.mode=\"throw\"] - specifies how to handle indices which exceed array dimensions\n* @param {StringArray} [options.submode=[\"throw\"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis\n* @param {boolean} [options.copy=false] - boolean indicating whether to copy source data to a new data buffer\n* @param {boolean} [options.flatten=true] - boolean indicating whether to automatically flatten generic array data sources\n* @param {NonNegativeInteger} [options.ndmin=0] - minimum number of dimensions\n* @param {string} [options.casting=\"safe\"] - casting rule used to determine what constitutes an acceptable cast\n* @param {boolean} [options.readonly=false] - boolean indicating if an array should be read-only\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {Error} must provide either an array shape, data source, or both\n* @throws {Error} invalid cast\n* @throws {RangeError} data source must be compatible with specified meta data\n* @returns {ndarray} ndarray instance\n*\n* @example\n* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n* // returns <ndarray>\n*\n* var v = arr.get( 0, 0 );\n* // returns 1\n*\n* @example\n* var opts = {\n*     'dtype': 'generic',\n*     'flatten': false\n* };\n*\n* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ], opts );\n* // returns <ndarray>\n*\n* var v = arr.get( 0 );\n* // returns [ 1, 2 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var opts = {\n*     'shape': [ 2, 2 ]\n* };\n*\n* var arr = array( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ), opts );\n* // returns <ndarray>\n*\n* var v = arr.get( 0, 0 );\n* // returns 1.0\n*/\nfunction array() {\n\tvar options;\n\tvar strides;\n\tvar buffer;\n\tvar offset;\n\tvar order;\n\tvar dtype;\n\tvar btype;\n\tvar shape;\n\tvar ndims;\n\tvar nopts;\n\tvar opts;\n\tvar osh;\n\tvar len;\n\tvar ord;\n\tvar FLG;\n\n\tif ( arguments.length === 1 ) {\n\t\tif ( isArrayLikeObject( arguments[ 0 ] ) ) {\n\t\t\tbuffer = arguments[ 0 ];\n\t\t\toptions = {};\n\t\t} else {\n\t\t\toptions = arguments[ 0 ];\n\t\t\tif ( !isObject( options ) ) {\n\t\t\t\tthrow new TypeError( format( '0hT56', options ) );\n\t\t\t}\n\t\t\tif ( hasOwnProp( options, 'buffer' ) ) {\n\t\t\t\tbuffer = options.buffer;\n\t\t\t\tif ( !isArrayLikeObject( buffer ) ) { // weak test\n\t\t\t\t\tthrow new TypeError( format( '0hT57', 'buffer', buffer ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbuffer = arguments[ 0 ];\n\t\tif ( !isArrayLikeObject( buffer ) ) { // weak test\n\t\t\tthrow new TypeError( format( '0hT58', buffer ) );\n\t\t}\n\t\toptions = arguments[ 1 ];\n\t\tif ( !isObject( options ) ) {\n\t\t\tthrow new TypeError( format( '0hT2V', options ) );\n\t\t}\n\t\t// Note: we ignore whether `options` has a `buffer` property\n\t}\n\tif ( buffer ) {\n\t\tif ( isndarrayLike( buffer ) ) {\n\t\t\tbtype = getDType( buffer );\n\t\t\tFLG = true;\n\t\t} else {\n\t\t\tbtype = getBufferDType( buffer );\n\t\t\tFLG = false;\n\t\t}\n\t}\n\tnopts = {};\n\topts = {};\n\n\t// Validate some options before others...\n\tif ( hasOwnProp( options, 'casting' ) ) {\n\t\topts.casting = options.casting;\n\t\tif ( !isCastingMode( opts.casting ) ) {\n\t\t\tthrow new TypeError( format( '0hT59', 'casting', opts.casting ) );\n\t\t}\n\t} else {\n\t\topts.casting = defaults.casting;\n\t}\n\tif ( hasOwnProp( options, 'flatten' ) ) {\n\t\topts.flatten = options.flatten;\n\t\tif ( !isBoolean( opts.flatten ) ) {\n\t\t\tthrow new TypeError( format( '0hT2o', 'flatten', opts.flatten ) );\n\t\t}\n\t} else {\n\t\topts.flatten = defaults.flatten;\n\t}\n\tif ( hasOwnProp( options, 'ndmin' ) ) {\n\t\topts.ndmin = options.ndmin;\n\t\tif ( !isNonNegativeInteger( opts.ndmin ) ) {\n\t\t\tthrow new TypeError( format( '0hT2t', 'ndmin', opts.ndmin ) );\n\t\t}\n\t\t// TODO: validate that minimum number of dimensions does not exceed the maximum number of possible dimensions (in theory, infinite; in practice, determined by max array length; see https://github.com/stdlib-js/stdlib/blob/ac350059877c036640775d6b30d0e98e840d07cf/lib/node_modules/%40stdlib/ndarray/ctor/lib/main.js#L57)\n\t} else {\n\t\topts.ndmin = defaults.ndmin;\n\t}\n\n\t// Validate the remaining options...\n\tif ( hasOwnProp( options, 'dtype' ) ) {\n\t\tdtype = options.dtype;\n\t\tif ( !isDataType( dtype ) ) {\n\t\t\tthrow new TypeError( format( '0hTBf', 'dtype', dtype ) );\n\t\t}\n\t\tif ( btype && !isAllowedCast( btype, dtype, opts.casting ) ) {\n\t\t\tthrow new Error( format( '0hT5B', opts.casting, btype, dtype ) );\n\t\t}\n\t} else if ( btype ) {\n\t\t// TODO: reconcile difference in behavior when provided a generic array and no `dtype` option. Currently, we cast here, but do not allow casting a generic array (by default) when explicitly providing a `dtype` option.\n\n\t\t// Only cast generic array data sources when not provided an ndarray...\n\t\tif ( !FLG && btype === 'generic' ) {\n\t\t\tdtype = defaults.dtype;\n\t\t} else {\n\t\t\tdtype = btype;\n\t\t}\n\t} else {\n\t\tdtype = defaults.dtype;\n\t}\n\tif ( hasOwnProp( options, 'order' ) ) {\n\t\torder = options.order;\n\t\tif ( order === 'any' || order === 'same' ) {\n\t\t\tif ( FLG ) {\n\t\t\t\t// If the user indicated that \"any\" order suffices (meaning the user does not care about ndarray order), then we use the default order, unless the input ndarray is either unequivocally \"row-major\" or \"column-major\" or configured as such....\n\t\t\t\tif ( order === 'any' ) {\n\t\t\t\t\t// Compute the layout order in order to ascertain whether an ndarray can be considered both \"row-major\" and \"column-major\":\n\t\t\t\t\tord = strides2order( getStrides( buffer ) );\n\n\t\t\t\t\t// If the ndarray can be considered both \"row-major\" and \"column-major\", then use the default order; otherwise, use the ndarray's stated layout order...\n\t\t\t\t\tif ( ord === 3 ) {\n\t\t\t\t\t\torder = defaults.order;\n\t\t\t\t\t} else {\n\t\t\t\t\t\torder = getOrder( buffer );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, use the same order as the provided ndarray...\n\t\t\t\telse if ( order === 'same' ) {\n\t\t\t\t\torder = getOrder( buffer );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\torder = defaults.order;\n\t\t\t}\n\t\t} else if ( !isOrder( order ) ) {\n\t\t\tthrow new TypeError( format( '0hT5C', 'order', order ) );\n\t\t}\n\t} else {\n\t\torder = defaults.order;\n\t}\n\tif ( hasOwnProp( options, 'mode' ) ) {\n\t\tnopts.mode = options.mode;\n\t} else {\n\t\tnopts.mode = defaults.mode;\n\t}\n\tif ( hasOwnProp( options, 'submode' ) ) {\n\t\tnopts.submode = options.submode;\n\t} else {\n\t\tnopts.submode = [ nopts.mode ];\n\t}\n\tif ( hasOwnProp( options, 'readonly' ) ) {\n\t\tnopts.readonly = options.readonly;\n\t} else {\n\t\tnopts.readonly = defaults.readonly;\n\t}\n\tif ( hasOwnProp( options, 'copy' ) ) {\n\t\topts.copy = options.copy;\n\t\tif ( !isBoolean( opts.copy ) ) {\n\t\t\tthrow new TypeError( format( '0hT2o', 'copy', opts.copy ) );\n\t\t}\n\t} else {\n\t\topts.copy = defaults.copy;\n\t}\n\t// If not provided a shape, infer from a provided data source...\n\tif ( hasOwnProp( options, 'shape' ) ) {\n\t\tshape = options.shape;\n\t\tif ( !isArrayLikeObject( shape ) ) { // weak test\n\t\t\tthrow new TypeError( format( '0hT5D', 'shape', shape ) );\n\t\t}\n\t\tndims = shape.length;\n\t\tlen = numel( shape );\n\t} else if ( buffer ) {\n\t\tif ( FLG ) {\n\t\t\tshape = getShape( buffer );\n\t\t\tndims = shape.length;\n\t\t\tlen = numel( shape );\n\t\t} else if ( opts.flatten && isArray( buffer ) ) {\n\t\t\tshape = arrayShape( buffer );\n\t\t\tosh = shape; // cache a reference to the inferred shape\n\t\t\tndims = shape.length;\n\t\t\tlen = numel( shape );\n\t\t} else {\n\t\t\tndims = 1;\n\t\t\tlen = buffer.length;\n\t\t\tshape = [ len ]; // assume a 1-dimensional array (vector)\n\t\t}\n\t} else {\n\t\tthrow new Error( format('0hT0X') );\n\t}\n\t// Adjust the array shape to satisfy the minimum number of dimensions...\n\tif ( ndims < opts.ndmin ) {\n\t\tshape = expandShape( ndims, shape, opts.ndmin );\n\t\tndims = opts.ndmin;\n\t}\n\t// If not provided a data buffer, create it; otherwise, see if we need to cast a provided data buffer to another data type or perform a copy...\n\tif ( FLG ) {\n\t\tif ( numel( buffer.shape ) !== len ) {\n\t\t\tthrow new RangeError( format('0hT0Y') );\n\t\t}\n\t\tif ( btype !== dtype || opts.copy ) {\n\t\t\tbuffer = copyView( buffer, dtype );\n\t\t} else {\n\t\t\tstrides = getStrides( buffer );\n\t\t\toffset = getOffset( buffer );\n\t\t\tbuffer = getData( buffer );\n\t\t\tif ( strides.length < ndims ) {\n\t\t\t\t// Account for augmented dimensions (note: expanding the strides array to account for prepended singleton dimensions does **not** affect the index offset):\n\t\t\t\tstrides = expandStrides( ndims, shape, strides, order );\n\t\t\t}\n\t\t}\n\t} else if ( buffer ) {\n\t\tif ( btype === 'generic' && opts.flatten ) {\n\t\t\tbuffer = flatten( buffer, osh || arrayShape( buffer ), order === 'column-major' );\n\t\t}\n\t\tif ( buffer.length !== len ) {\n\t\t\tthrow new RangeError( format('0hT0Y') );\n\t\t}\n\t\tif ( btype !== dtype || opts.copy ) {\n\t\t\tbuffer = castBuffer( buffer, len, dtype );\n\t\t}\n\t} else {\n\t\tbuffer = createBuffer( dtype, len );\n\t}\n\t// If we have yet to determine array strides, we assume that we can compute the strides, along with the index offset, for a **contiguous** data source based solely on the array shape and specified memory layout order...\n\tif ( strides === void 0 ) {\n\t\tstrides = shape2strides( shape, order );\n\t\toffset = strides2offset( shape, strides );\n\t}\n\treturn new ndarray( dtype, buffer, shape, strides, offset, order, nopts );\n}\n\n\n// EXPORTS //\n\nexport default array;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport settings from '@stdlib/ndarray-defaults';\n\n\n// MAIN //\n\n/**\n* Returns default options.\n*\n* @private\n* @returns {Object} default options\n*\n* @example\n* var o = defaults();\n* // returns {...}\n*/\nfunction defaults() {\n\treturn {\n\t\t'casting': settings.get( 'casting' ),\n\t\t'copy': false,\n\t\t'dtype': settings.get( 'dtypes.default' ),\n\t\t'flatten': true,\n\t\t'mode': settings.get( 'index_mode' ),\n\t\t'ndmin': 0,\n\t\t'order': settings.get( 'order' ),\n\t\t'readonly': false\n\t};\n}\n\n\n// EXPORTS //\n\nexport default defaults;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Prepends singleton dimensions in order to satisfy a minimum number of dimensions.\n*\n* @private\n* @param {NonNegativeInteger} ndims - number of dimensions\n* @param {Array} shape - array dimensions\n* @param {NonNegativeInteger} ndmin - minimum number of dimensions\n* @returns {Array} output shape array\n*/\nfunction expandShape( ndims, shape, ndmin ) {\n\tvar out;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < ndmin-ndims; i++ ) {\n\t\tout.push( 1 );\n\t}\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\tout.push( shape[ i ] );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default expandShape;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport abs from '@stdlib/math-base-special-abs';\n\n\n// MAIN //\n\n/**\n* Expands a strides array to accommodate an expanded array shape (i.e., an array shape with prepended singleton dimensions).\n*\n* @private\n* @param {NonNegativeInteger} ndims - number of dimensions\n* @param {Array} shape - expanded array shape\n* @param {Array} strides - strides array\n* @param {string} order - memory layout order\n* @returns {Array} output strides array\n*\n* @example\n* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 1, 2 ], 'column-major' );\n* // returns [ 1, 1, 1, 2 ]\n*\n* @example\n* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 2, 1 ], 'row-major' );\n* // returns [ 4, 4, 2, 1 ]\n*/\nfunction expandStrides( ndims, shape, strides, order ) {\n\tvar out;\n\tvar N;\n\tvar s;\n\tvar i;\n\tvar j;\n\n\tN = strides.length;\n\tj = ndims - N;\n\tout = [];\n\tif ( order === 'row-major' ) {\n\t\ts = abs( strides[ 0 ] ) * shape[ j ]; // at `j` is the size of the first non-prepended dimension\n\t\tfor ( i = 0; i < j; i++ ) {\n\t\t\tout.push( s );\n\t\t}\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tout.push( strides[ i ] );\n\t\t}\n\t} else { // column-major\n\t\tfor ( i = 0; i < j; i++ ) {\n\t\t\tout.push( 1 );\n\t\t}\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tout.push( strides[ i ] );\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default expandStrides;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport bufferCtors from '@stdlib/ndarray-base-buffer-ctors';\nimport allocUnsafe from '@stdlib/buffer-alloc-unsafe';\n\n\n// MAIN //\n\n/**\n* Casts buffer elements by copying those elements to a buffer of another data type.\n*\n* @private\n* @param {(Array|TypedArray|Buffer)} buffer - input buffer\n* @param {NonNegativeInteger} len - number of elements to cast\n* @param {string} dtype - data type\n* @returns {(Array|TypedArray|Buffer)} output buffer\n*\n* @example\n* var b = castBuffer( [ 1.0, 2.0, 3.0 ], 3, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0 ]\n*/\nfunction castBuffer( buffer, len, dtype ) {\n\tvar ctor;\n\tvar out;\n\tvar i;\n\n\tctor = bufferCtors( dtype );\n\tif ( dtype === 'generic' ) {\n\t\tout = [];\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout.push( buffer[ i ] );\n\t\t}\n\t} else if ( dtype === 'binary' ) {\n\t\tout = allocUnsafe( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = buffer[ i ];\n\t\t}\n\t} else {\n\t\tout = new ctor( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = buffer[ i ]; // TODO: wrap and use accessors here and above\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default castBuffer;\n"],"names":["isArrayLikeObject","value","length","isInteger","PINF","copyView","arr","dtype","x","ndarray","getDType","getData","getShape","getStrides","getOffset","getOrder","len","out","i","push","iget","generic","allocUnsafe","binary","set","fcn","o","bufferCtors","arraylike2object","accessorProtocol","accessors","castReturn","complexCtors","typed","defaults","casting","settings","get","copy","flatten","mode","ndmin","order","readonly","array","options","strides","buffer","offset","btype","shape","ndims","nopts","opts","osh","FLG","arguments","isObject","TypeError","format","hasOwnProp","isndarrayLike","getBufferDType","isCastingMode","isBoolean","isNonNegativeInteger","isDataType","isAllowedCast","Error","strides2order","isOrder","submode","numel","isArray","arrayShape","expandShape","RangeError","N","s","j","abs","expandStrides","ctor","castBuffer","createBuffer","shape2strides","strides2offset"],"mappings":";;46GA2CA,SAASA,EAAmBC,GAC3B,MACkB,iBAAVA,GACG,OAAVA,GACwB,iBAAjBA,EAAMC,QACbC,EAAWF,EAAMC,SACjBD,EAAMC,QAAU,GAChBD,EAAMC,OAASE,CAEjB,CCgGA,SAASC,EAAUC,EAAKC,GACvB,IAAIC,EAKJ,OAFAA,EAAI,IAAIC,EAASC,EAAUJ,GAAOK,EAASL,GAAOM,EAAUN,GAAOO,EAAYP,GAAOQ,EAAWR,GAAOS,EAAUT,IAEnG,YAAVC,EA7GN,SAAkBD,GACjB,IAAIU,EACAC,EACAC,EAIJ,IAFAF,EAAMV,EAAIJ,OACVe,EAAM,GACAC,EAAI,EAAGA,EAAIF,EAAKE,IACrBD,EAAIE,KAAMb,EAAIc,KAAMF,IAErB,OAAOD,CACR,CAmGSI,CAASb,GAEF,WAAVD,EA5FN,SAAiBD,GAChB,IAAIU,EACAC,EACAC,EAIJ,IAFAF,EAAMV,EAAIJ,OACVe,EAAMK,EAAaN,GACbE,EAAI,EAAGA,EAAIF,EAAKE,IACrBD,EAAKC,GAAMZ,EAAIc,KAAMF,GAEtB,OAAOD,CACR,CAkFSM,CAAQf,GAxEjB,SAAgBF,EAAKC,GACpB,IACIS,EACAC,EACAO,EACAC,EACAC,EACAR,EAQJ,GAJAD,EAAM,IAFCU,EAAapB,GAEd,CADNS,EAAMV,EAAIJ,SAIVwB,EAAIE,EAAkBX,IACfY,iBAGN,IAFAL,EAAME,EAAEI,UAAW,GACnBL,EAAMM,GAkBP,SAAkBb,GACjB,OAAOZ,EAAIc,KAAMF,EACjB,GApB2B,EAAGc,EAAczB,IACtCW,EAAI,EAAGA,EAAIF,EAAKE,IACrBM,EAAKP,EAAKC,EAAGO,EAAKP,SAGnB,IAAMA,EAAI,EAAGA,EAAIF,EAAKE,IACrBD,EAAKC,GAAMZ,EAAIc,KAAMF,GAGvB,OAAOD,CAYR,CAoCQgB,CAAOzB,EAAGD,EAClB,CCvGA,IAAI2B,ECpBI,CACNC,QAAWC,EAASC,IAAK,WACzBC,MAAQ,EACR/B,MAAS6B,EAASC,IAAK,kBACvBE,SAAW,EACXC,KAAQJ,EAASC,IAAK,cACtBI,MAAS,EACTC,MAASN,EAASC,IAAK,SACvBM,UAAY,GDwEd,SAASC,IACR,IAAIC,EACAC,EACAC,EACAC,EACAN,EACAnC,EACA0C,EACAC,EACAC,EACAC,EACAC,EACAC,EACAtC,EAEAuC,EAEJ,GAA0B,IAArBC,UAAUtD,OACd,GAAKF,EAAmBwD,UAAW,IAClCT,EAASS,UAAW,GACpBX,EAAU,CAAA,MACJ,CAEN,IAAMY,EADNZ,EAAUW,UAAW,IAEpB,MAAM,IAAIE,UAAWC,EAAQ,QAASd,IAEvC,GAAKe,EAAYf,EAAS,YAEnB7C,EADN+C,EAASF,EAAQE,QAEhB,MAAM,IAAIW,UAAWC,EAAQ,QAAS,SAAUZ,GAGlD,KACK,CAEN,IAAM/C,EADN+C,EAASS,UAAW,IAEnB,MAAM,IAAIE,UAAWC,EAAQ,QAASZ,IAGvC,IAAMU,EADNZ,EAAUW,UAAW,IAEpB,MAAM,IAAIE,UAAWC,EAAQ,QAASd,GAGvC,CAcD,GAbKE,IACCc,EAAed,IACnBE,EAAQvC,EAAUqC,GAClBQ,GAAM,IAENN,EAAQa,EAAgBf,GACxBQ,GAAM,IAGRH,EAAQ,CAAA,EACRC,EAAO,CAAA,EAGFO,EAAYf,EAAS,YAEzB,GADAQ,EAAKlB,QAAUU,EAAQV,SACjB4B,EAAeV,EAAKlB,SACzB,MAAM,IAAIuB,UAAWC,EAAQ,QAAS,UAAWN,EAAKlB,eAGvDkB,EAAKlB,QAAUD,EAASC,QAEzB,GAAKyB,EAAYf,EAAS,YAEzB,GADAQ,EAAKd,QAAUM,EAAQN,SACjByB,EAAWX,EAAKd,SACrB,MAAM,IAAImB,UAAWC,EAAQ,QAAS,UAAWN,EAAKd,eAGvDc,EAAKd,QAAUL,EAASK,QAEzB,GAAKqB,EAAYf,EAAS,UAEzB,GADAQ,EAAKZ,MAAQI,EAAQJ,OACfwB,EAAsBZ,EAAKZ,OAChC,MAAM,IAAIiB,UAAWC,EAAQ,QAAS,QAASN,EAAKZ,aAIrDY,EAAKZ,MAAQP,EAASO,MAIvB,GAAKmB,EAAYf,EAAS,SAAY,CAErC,GADAtC,EAAQsC,EAAQtC,OACV2D,EAAY3D,GACjB,MAAM,IAAImD,UAAWC,EAAQ,QAAS,QAASpD,IAEhD,GAAK0C,IAAUkB,EAAelB,EAAO1C,EAAO8C,EAAKlB,SAChD,MAAM,IAAIiC,MAAOT,EAAQ,QAASN,EAAKlB,QAASc,EAAO1C,GAExD,MAOCA,EAPU0C,IAILM,GAAiB,YAAVN,GAGJA,EAGDf,EAAS3B,MAElB,GAAKqD,EAAYf,EAAS,UAEzB,GAAe,SADfH,EAAQG,EAAQH,QACkB,SAAVA,EAClBa,EAEW,QAAVb,EAMHA,EADY,IAHP2B,EAAexD,EAAYkC,IAIxBb,EAASQ,MAET3B,EAAUgC,GAIA,SAAVL,IACTA,EAAQ3B,EAAUgC,IAGnBL,EAAQR,EAASQ,WAEZ,IAAM4B,EAAS5B,GACrB,MAAM,IAAIgB,UAAWC,EAAQ,QAAS,QAASjB,SAGhDA,EAAQR,EAASQ,MAiBlB,GAfKkB,EAAYf,EAAS,QACzBO,EAAMZ,KAAOK,EAAQL,KAErBY,EAAMZ,KAAON,EAASM,KAElBoB,EAAYf,EAAS,WACzBO,EAAMmB,QAAU1B,EAAQ0B,QAExBnB,EAAMmB,QAAU,CAAEnB,EAAMZ,MAEpBoB,EAAYf,EAAS,YACzBO,EAAMT,SAAWE,EAAQF,SAEzBS,EAAMT,SAAWT,EAASS,SAEtBiB,EAAYf,EAAS,SAEzB,GADAQ,EAAKf,KAAOO,EAAQP,MACd0B,EAAWX,EAAKf,MACrB,MAAM,IAAIoB,UAAWC,EAAQ,QAAS,OAAQN,EAAKf,YAGpDe,EAAKf,KAAOJ,EAASI,KAGtB,GAAKsB,EAAYf,EAAS,SAAY,CAErC,IAAM7C,EADNkD,EAAQL,EAAQK,OAEf,MAAM,IAAIQ,UAAWC,EAAQ,QAAS,QAAST,IAEhDC,EAAQD,EAAMhD,OACdc,EAAMwD,EAAOtB,EACb,KAAM,KAAKH,EAgBX,MAAM,IAAIqB,MAAOT,EAAO,UAfnBJ,GAEJJ,GADAD,EAAQtC,EAAUmC,IACJ7C,OACdc,EAAMwD,EAAOtB,IACFG,EAAKd,SAAWkC,EAAS1B,IAEpCO,EADAJ,EAAQwB,EAAY3B,GAEpBI,EAAQD,EAAMhD,OACdc,EAAMwD,EAAOtB,KAEbC,EAAQ,EAERD,EAAQ,CADRlC,EAAM+B,EAAO7C,QAKd,CAOD,GALKiD,EAAQE,EAAKZ,QACjBS,EE/QF,SAAsBC,EAAOD,EAAOT,GACnC,IAAIxB,EACAC,EAGJ,IADAD,EAAM,GACAC,EAAI,EAAGA,EAAIuB,EAAMU,EAAOjC,IAC7BD,EAAIE,KAAM,GAEX,IAAMD,EAAI,EAAGA,EAAIiC,EAAOjC,IACvBD,EAAIE,KAAM+B,EAAOhC,IAElB,OAAOD,CACR,CFmQU0D,CAAaxB,EAAOD,EAAOG,EAAKZ,OACxCU,EAAQE,EAAKZ,OAGTc,EAAM,CACV,GAAKiB,EAAOzB,EAAOG,SAAYlC,EAC9B,MAAM,IAAI4D,WAAYjB,EAAO,UAEzBV,IAAU1C,GAAS8C,EAAKf,KAC5BS,EAAS1C,EAAU0C,EAAQxC,IAE3BuC,EAAUjC,EAAYkC,GACtBC,EAASlC,EAAWiC,GACpBA,EAASpC,EAASoC,GACbD,EAAQ5C,OAASiD,IAErBL,EGjRJ,SAAwBK,EAAOD,EAAOJ,EAASJ,GAC9C,IAAIzB,EACA4D,EACAC,EACA5D,EACA6D,EAKJ,GAFAA,EAAI5B,GADJ0B,EAAI/B,EAAQ5C,QAEZe,EAAM,GACS,cAAVyB,EAAwB,CAE5B,IADAoC,EAAIE,EAAKlC,EAAS,IAAQI,EAAO6B,GAC3B7D,EAAI,EAAGA,EAAI6D,EAAG7D,IACnBD,EAAIE,KAAM2D,GAEX,IAAM5D,EAAI,EAAGA,EAAI2D,EAAG3D,IACnBD,EAAIE,KAAM2B,EAAS5B,GAEtB,KAAQ,CACN,IAAMA,EAAI,EAAGA,EAAI6D,EAAG7D,IACnBD,EAAIE,KAAM,GAEX,IAAMD,EAAI,EAAGA,EAAI2D,EAAG3D,IACnBD,EAAIE,KAAM2B,EAAS5B,GAEpB,CACD,OAAOD,CACR,CHsPcgE,CAAe9B,EAAOD,EAAOJ,EAASJ,IAGlD,MAAM,GAAKK,EAAS,CAIpB,GAHe,YAAVE,GAAuBI,EAAKd,UAChCQ,EAASR,EAASQ,EAAQO,GAAOoB,EAAY3B,GAAoB,iBAAVL,IAEnDK,EAAO7C,SAAWc,EACtB,MAAM,IAAI4D,WAAYjB,EAAO,WAEzBV,IAAU1C,GAAS8C,EAAKf,QAC5BS,EIhSH,SAAqBA,EAAQ/B,EAAKT,GACjC,IAAI2E,EACAjE,EACAC,EAGJ,GADAgE,EAAOvD,EAAapB,GACL,YAAVA,EAEJ,IADAU,EAAM,GACAC,EAAI,EAAGA,EAAIF,EAAKE,IACrBD,EAAIE,KAAM4B,EAAQ7B,SAEb,GAAe,WAAVX,EAEX,IADAU,EAAMK,EAAaN,GACbE,EAAI,EAAGA,EAAIF,EAAKE,IACrBD,EAAKC,GAAM6B,EAAQ7B,QAIpB,IADAD,EAAM,IAAIiE,EAAMlE,GACVE,EAAI,EAAGA,EAAIF,EAAKE,IACrBD,EAAKC,GAAM6B,EAAQ7B,GAGrB,OAAOD,CACR,CJyQYkE,CAAYpC,EAAQ/B,EAAKT,GAErC,MACEwC,EAASqC,EAAc7E,EAAOS,GAO/B,YAJiB,IAAZ8B,IACJA,EAAUuC,EAAenC,EAAOR,GAChCM,EAASsC,EAAgBpC,EAAOJ,IAE1B,IAAIrC,EAASF,EAAOwC,EAAQG,EAAOJ,EAASE,EAAQN,EAAOU,EACnE"}